import ch.so.agi.gretl.api.TransferSet
import ch.so.agi.gretl.tasks.*
import java.nio.file.Paths
import java.nio.file.Files
import de.undercouch.gradle.tasks.download.Download
import groovy.json.JsonSlurper
import java.text.SimpleDateFormat
import java.util.Date
import java.util.ArrayList
import java.util.Iterator
import java.util.List
import java.util.zip.GZIPInputStream


apply plugin: "de.undercouch.download"
apply plugin: 'ch.so.agi.gretl'


defaultTasks 'transferAfUInfofloraPub'

def pathToTempFolder = System.getProperty("java.io.tmpdir")
def pathToUnzipFolder = Paths.get(pathToTempFolder)
def pathToDataZip = Paths.get(pathToTempFolder, 'neophyten.gz')
def csvFilePath = Paths.get(pathToUnzipFolder.toString(), 'data', 'data.csv')


ext.filepath = 'foo'
ext.filename = 'bar'
ext.fileid = new ArrayList<String>()


task download_json(type: Download){
    description = "Download Json with filename"
    doLast {
        def inputFile = new File(pathToTempFolder + "/filenames.json")
        def json = new JsonSlurper().parseText(inputFile.text)
        def sortedJson = json.data.sort {a, b -> b.last_modified_when <=> a.last_modified_when}

        /*Hier wird festgelegt, welches file auf dem Server gelöscht wird! */        
        SimpleDateFormat sdfo = new SimpleDateFormat("yyyy-MM-dd")
        Date date = new Date()
        Date todayDate = sdfo.parse(sdfo.format(date)) 
        sortedJson.each {
			if (it.last_modified_when == null) {
                project.fileid.add(it.id)
            }
            else {
                Date fileDate = sdfo.parse(it.last_modified_when)
                if ((todayDate - fileDate) > 2) {
                    project.fileid.add(it.id)
                }
            }
            /* Falls Gewünscht, dass nur das aktuelle file (0 Tage alt) importiert wird. Andersfalls wird einfach das neuste importiert.
            if ((todayDate - fileDate) == 0) {
                project.filename = it.file_name 
                project.filepath = it.folder_name    
                println "Filename = " + filename
            }
        */
        }
        project.filename = sortedJson.file_name[0]
        project.filepath = sortedJson.folder_name[0]

        if (project.filename == 'bar') {
            throw new GradleException("Kein file auf dem Server!")
        }
    }
    src 'https://obs.infoflora.ch/rest/v4/docs.json?projects=83505'
    username infofloraUser
    password infofloraPwd
    dest new File(pathToTempFolder, 'filenames.json')
    overwrite true
}

task download_file(dependsOn: download_json){
    description = "Download Zip file"

    def localFileName = 'foo' 
    def localPath = '/bar'
    def url = 'https://obs.infoflora.ch/'

    doFirst {
        localFileName = project.filename
        localPath = project.filepath
        url = 'https://obs.infoflora.ch' + localPath + '/' + localFileName 
    }
    doLast {
        download {
            src url
            dest file(pathToDataZip)
            overwrite true
        }
        println "FileSize = " + file(pathToDataZip).size()
    }
}

task unpackFiles(dependsOn: download_file){ 
    doLast {
        GZIPInputStream gis = new GZIPInputStream(
            new FileInputStream(pathToDataZip.toFile())
        )
        Files.copy(gis, Paths.get(pathToUnzipFolder.toString()+'/neophyten'))
    }
}


task truncateTable(type: SqlExecutor, dependsOn:unpackFiles) {
    description = "Leert die Tabelle afu_infoflora.neophyten_neophytenstandorte"
    database = [dbUriEdit, dbUserEdit, dbPwdEdit]
    sqlFiles = [
            'truncate_table.sql'
    ]
}

task csvimport(type: CsvImport, dependsOn: truncateTable){
    database = [dbUriEdit, dbUserEdit, dbPwdEdit]
    schemaName = "afu_infoflora"
    tableName = "neophyten_neophytenstandorte"
    firstLineIsHeader=true
    valueSeparator = ";"
    encoding = "UTF-8"
    println "Importiere folgendes file: "+pathToUnzipFolder.toString()+'/neophyten'
    dataFile = file(pathToUnzipFolder.toString()+'/neophyten')
}

task makeGeometry(type: SqlExecutor, dependsOn:csvimport){
    description = "Macht aus x und y Koordinate eine Geometrie"
    database = [dbUriEdit, dbUserEdit, dbPwdEdit]
    sqlFiles = [
            'makegeometry.sql'
    ]
}

task deleteFileOnServer(dependsOn: makeGeometry){
    doLast {
        if (project.fileid.isEmpty()) {
            println "No file will be deleted!"
        }
        else {
            for (String localFileid : project.fileid) {
                exec {
                    workingDir '/tmp'
                    commandLine 'curl', '-i', '--http1.1', '-u', infofloraUser + ':' + infofloraPwd, '-k', '-X', 'DELETE', '--header', 'Content-Type:application/json', 'https://obs.infoflora.ch/rest/v4/docs/'+localFileid+'.json'
                    println "Deleted file ID: " + localFileid + " from Server"
                }
            }
        }    
    }
}

task transferAfUInfofloraPub(type: Db2Db, dependsOn: deleteFileOnServer){
    sourceDb = [dbUriEdit, dbUserEdit, dbPwdEdit]
    targetDb = [dbUriPub, dbUserPub, dbPwdPub]
    transferSets = [
            new TransferSet('afu_infoflora_pub.sql', 'afu_infoflora_pub.neophyten_neophytenstandorte', true)
    ];
}

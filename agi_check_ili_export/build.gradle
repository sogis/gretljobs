import java.nio.file.Paths
import ch.so.agi.gretl.tasks.*


apply plugin: 'ch.so.agi.gretl'

description = """\n
Exportiert sämtliche modellbasierten Datenerfassungen in eine 
INTERLIS-Transferdatei, um die Modellkonformität zu prüfen.

In Zukunft könnte auch eine direktere Prüfung in der Datenbank
stattfinden, ohne zu versuchen die Datei zu exportieren
(Feature request für ilivalidator).
"""

apply plugin: 'ch.so.agi.gretl'

defaultTasks 'checkAllModels'

ext {
    todaysDate = new Date().format('yyyy-MM-dd')
    models = []
    models.add(["SO_Agglomerationsprogramme_20170512", "arp_aggloprogramme", "arp_aggloprogramme_" + todaysDate ])
    models.add(["SO_ARP_Nutzungsvereinbarung_20170512", "arp_nutzungsvereinbarung",
                "arp_nutzungsvereinbarung_" + todaysDate ])
    models.add(["SO_Forstreviere_20170512", "awjf_forstreviere", "awjf_forstreviere_" + todaysDate ])
    models.add(["SO_Hoheitsgrenzen_20170623", "agi_hoheitsgrenzen", "agi_hoheitsgrenzen_" + todaysDate ])
    models.add(["SO_AWJF_Wegsanierungen_20170629", "awjf_wegsanierungen", "awjf_wegsanierungen_" + todaysDate ])
    models.add(["SO_BLN_20170904", "arp_bln", "arp_bln_" + todaysDate ])
    models.add(["SO_ALW_Vernetzung_20171010", "alw_vernetzung", "alw_vernetzung_" + todaysDate ])
    models.add(["SO_AWJF_Biotopbaeume_20171213", "awjf_biotopbaeume", "awjf_biotopbaeume_" + todaysDate ])
    models.add(["SO_AMB_Notfalltreffpunkte_20180413", "amb_notfalltreffpunkte", "amb_notfalltreffpunkte_" + todaysDate ])
    models.add(["SO_AGI_AV_GB_Administrative_Einteilungen_20180613", "agi_av_gb_admin_einteilung",
                "agi_av_gb_admin_einteilung_" + todaysDate ])
    models.add(["SO_ARP_Naturreservate_20180829", "arp_naturreservate", "arp_naturreservate_" + todaysDate ])
}

def stringPathToTempFolder = System.getProperty("java.io.tmpdir").toString()

def failingModel

// Create a dynamic task for every model we want to validate and for cleaning up if validaton was successful.
models.each { model ->
    def modelName = model.getAt(0)
    def dbSchema = model.getAt(1)
    def filename = model.getAt(2)
    def dataExists

    
    task "checkModel_$modelName"(type: Ili2pgExport) {
        description = "INTERLIS validation against database schema: $dbSchema ($modelName)"
        database = [dbUriSogis, dbUserSogis, dbPwdSogis]
        dbschema = dbSchema
        models = modelName
        disableValidation = false
        logFile = file(Paths.get(stringPathToTempFolder, filename + ".log"))
        dataFile = file(Paths.get(stringPathToTempFolder, filename + ".xtf"))

        finalizedBy "removeFiles_$modelName"
    }

    task "checkDataFileForData_$modelName"(){
        description = "Temporary workaround until ili2pgExport works correctly on failure during export. " +
                "Checks if there is any data within datasection."
        doLast {
            def dataFile = file(Paths.get(stringPathToTempFolder, filename + ".xtf"))
            def indexStartDatasection = dataFile.findLastIndexOf { it =~ "<DATASECTION>" }
            def indexEndDatasection = dataFile.findLastIndexOf { it =~ "</DATASECTION>" }
            def lineDifference = indexEndDatasection - indexStartDatasection

            if (lineDifference <= 1){
                dataExists = false
                //throw new GradleException("No Data exported")
            } else if (lineDifference > 1) {
                dataExists = true
            }
        }
    }

    task "removeFiles_$modelName"(type: Delete, dependsOn: "checkDataFileForData_$modelName") {
        description = "Remove files from model export: $modelName"

        onlyIf {
            //project.getTasksByName("checkModel_$modelName", false).getAt(0).state.failure == null
            dataExists
        }

        delete file(Paths.get(stringPathToTempFolder, filename + ".log")),
                file(Paths.get(stringPathToTempFolder, filename + ".xtf"))
    }
}

task checkAllModels() {
    description = "Validate all models."
    //ignoreFailures = true
}

checkAllModels.finalizedBy {
    tasks.findAll { task -> task.name.startsWith('checkModel_') }
}


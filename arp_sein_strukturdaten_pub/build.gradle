import ch.so.agi.gretl.tasks.*
import ch.so.agi.gretl.api.TransferSet

apply plugin: 'ch.so.agi.gretl'
apply plugin: 'org.hidetake.ssh'

defaultTasks "upload"

// Definition von Pfaden
def xtfPath = "${buildDir}/arp_sein_strukturdaten.xtf"
def ftpPath = "/opt/daten/gis_arp_raumdaten/test/"  // tbd: produktives Verzeichnis = ?

// Multiline-Text ist im Task nicht möglich, darum als Variable
def importModels = 
    "SO_AGI_MOpublic_20240711;" +
    "SO_AGI_GWR_Publikation_20241118;" +
    "SO_ARP_STATPOP_STATENT_20221114;" +
    "SO_ARP_Auswertungen_Nutzungsplanung_Publikation_20210126;" +
    "SO_ARP_Nutzungsplanung_Publikation_20201005;" +
    "SO_Hoheitsgrenzen_Publikation_20170626;" +
    "SO_ARP_SEin_Konfiguration_20250115"

/* tbd wieder einkommentieren
// Definition des SFTP-Servers für den Datenupload
remotes {
    sftpServer {
        host = "${sftpServerSEinApp}"
        user = "${sftpUserSEinApp}"
        identity = file('/home/gradle/.ssh/id_rsa')
        // Skip host key checking outside the following environments:
        if ( !(gretlEnvironment in ['test', 'integration', 'production']) ) {  // uses the Groovy membership operator
            knownHosts = allowAnyHosts
        }
    }
}
*/

// In der processing DB die Extension für die UUID-Erstellung aktivieren (uuid-ossp)
task createExtension(type: SqlExecutor){
    database = [dbUriProcessing, dbUserProcessing, dbPwdProcessing]
    sqlFiles = ['create_extension.sql']
}

// Schema "import" für Quelldaten in processing DB anlegen
task createImportSchema(type: Ili2pgImportSchema, dependsOn: createExtension){
    database = [dbUriProcessing, dbUserProcessing, dbPwdProcessing]
    models = importModels
    dbschema = "import"
    nameByTopic = true
    beautifyEnumDispName = true
    strokeArcs = true
    createEnumTabs = false
    createNumChecks = true
    createFk = true
    createFkIdx = true
    createGeomIdx = true
    createMetaInfo = true
    createBasketCol = false
    createUnique = true
    smart2Inheritance = true
}

// Schema "export" für Ausgabedaten in processing DB anlegen
task createExportSchema(type: Ili2pgImportSchema, dependsOn: createImportSchema){
    database = [dbUriProcessing, dbUserProcessing, dbPwdProcessing]
    models = "SO_ARP_SEin_Strukturdaten_Publikation_20250407"
    dbschema = "export"
    nameByTopic = true
    beautifyEnumDispName = true
    strokeArcs = true
    createEnumTabs = false
    createNumChecks = true
    createFk = true
    createFkIdx = true
    createGeomIdx = true
    createMetaInfo = true
    createBasketCol = false
    createUnique = true
    smart2Inheritance = true
}

// Quelldaten tabellenweise aus Pub nach Processing kopieren
task copyDataFromPub(type: Db2Db, dependsOn: createExportSchema){ 
    sourceDb = [dbUriPub, dbUserPub, dbPwdPub]
    targetDb = [dbUriProcessing, dbUserProcessing, dbPwdProcessing]
    transferSets = [
        new TransferSet('import_to_processing/import_bauzonenstatistik_liegenschaft_nach_bebauungsstand.sql', 'import.bauzonenstatistik_liegenschaft_nach_bebauungsstand', true),
        new TransferSet('import_to_processing/import_nutzungsplanung_grundnutzung.sql', 'import.nutzungsplanung_grundnutzung', true),
        new TransferSet('import_to_processing/import_mopublic_bodenbedeckung.sql', 'import.mopublic_bodenbedeckung', true),
        new TransferSet('import_to_processing/import_mopublic_grundstueck.sql', 'import.mopublic_grundstueck', true),
        new TransferSet('import_to_processing/import_gwr_gebaeude.sql', 'import.gwr_gebaeude', true),
        new TransferSet('import_to_processing/import_gwr_wohnung.sql', 'import.gwr_wohnung', true),
        new TransferSet('import_to_processing/import_hoheitsgrenzen_gemeindegrenze.sql', 'import.hoheitsgrenzen_gemeindegrenze', true)
    ];
}

// Quelldaten tabellenweise aus Edit nach Processing kopieren
task copyDataFromEdit(type: Db2Db, dependsOn: copyDataFromPub){ 
    sourceDb = [dbUriEdit, dbUserEdit, dbPwdEdit]
    targetDb = [dbUriProcessing, dbUserProcessing, dbPwdProcessing]
    transferSets = [
        new TransferSet('import_to_processing/import_statpop.sql', 'import.statpop_statent_statpop', true),
        new TransferSet('import_to_processing/import_statent.sql', 'import.statpop_statent_statent', true),
        new TransferSet('import_to_processing/import_grundlagen_gemeinde.sql', 'import.grundlagen_gemeinde', true)
    ];
}

// Raumeinheit Parzelle aufbereiten
task processParzellen(type: SqlExecutor, dependsOn: copyDataFromEdit) {
    database = [dbUriProcessing, dbUserProcessing, dbPwdProcessing]
    sqlFiles = [
        'process_parzellen/gebklasse10_mapping.sql',
        'process_parzellen/parzellen_basis.sql',
        'process_parzellen/parzellen_bodenbedeckung.sql',
        'process_parzellen/gebaeude.sql',
        'process_parzellen/wohnung.sql',
        'process_parzellen/statpop.sql',
        'process_parzellen/statent.sql',
        'process_parzellen/parzellen_grundnutzungen_array.sql',
        'process_parzellen/parzellen_bodenbedeckungen_array.sql',
        'process_parzellen/parzellen_gwr_array.sql',
        'process_parzellen/parzellen_gwr_geb_agg.sql',
        'process_parzellen/parzellen_gwr_wohn_agg.sql',
        'process_parzellen/parzellen_statpop_array.sql',
        'process_parzellen/parzellen_statent_agg.sql',
        'process_parzellen/strukturdaten_parzelle.sql'
    ]
}

// Raumeinheit Zonentyp aufbereiten (bedingt Parzellen-Daten)
task processZonentypen(type: SqlExecutor, dependsOn: processParzellen) {
    database = [dbUriProcessing, dbUserProcessing, dbPwdProcessing]
    sqlFiles = [
        'process_zonentypen/zonentyp_basis.sql',
        'process_zonentypen/zonentyp_bodenbedeckung.sql',
        'process_zonentypen/zonentyp_grundnutzungen_array.sql',
        'process_zonentypen/zonentyp_bodenbedeckungen_array.sql',
        'process_zonentypen/zonentyp_gwr_array.sql',
        'process_zonentypen/zonentyp_gwr_geb_agg.sql',
        'process_zonentypen/zonentyp_gwr_wohn_agg.sql',
        'process_zonentypen/zonentyp_statpop_array.sql',
        'process_zonentypen/zonentyp_statent_agg.sql',
        'process_zonentypen/strukturdaten_zonentyp.sql'
    ]
}

// Raumeinheit Zonenschild aufbereiten (bedingt Zonentyp- und Parzellen-Daten)
task processZonenschilde(type: SqlExecutor, dependsOn: processZonentypen) {
    database = [dbUriProcessing, dbUserProcessing, dbPwdProcessing]
    sqlFiles = [
        'process_zonenschilde/zonenschild_dump.sql',
        'process_zonenschilde/zonenschild_basis.sql',
        'process_zonenschilde/zonenschild_bodenbedeckung.sql',
        'process_zonenschilde/zonenschild_grundnutzungen_array.sql',
        'process_zonenschilde/zonenschild_bodenbedeckungen_array.sql',
        'process_zonenschilde/gebaeude_x_zonenschild.sql',
        'process_zonenschilde/wohnung_x_zonenschild.sql',
        'process_zonenschilde/zonenschild_gwr_array.sql',
        'process_zonenschilde/zonenschild_gwr_geb_agg.sql',
        'process_zonenschilde/zonenschild_gwr_wohn_agg.sql',
        'process_zonenschilde/zonenschild_basis_statpop.sql',
        'process_zonenschilde/zonenschild_basis_statent.sql',
        'process_zonenschilde/zonenschild_statpop_array.sql',
        'process_zonenschilde/zonenschild_statent_agg.sql',
        'process_zonenschilde/strukturdaten_zonenschild.sql'
    ]
}

// Raumeinheit Gemeinde aufbereiten (bedingt zonentyp.sql und somit parzelle.sql)
task processGemeinden(type: SqlExecutor, dependsOn: processZonentypen) {
    database = [dbUriProcessing, dbUserProcessing, dbPwdProcessing]
    sqlFiles = [
        'process_gemeinden/gemeinde_basis.sql',
        'process_gemeinden/gemeinde_bodenbedeckung.sql',
        'process_gemeinden/gemeinde_grundnutzungen_array.sql',
        'process_gemeinden/gemeinde_bodenbedeckungen_array.sql',
        'process_gemeinden/gemeinde_gwr_array.sql',
        'process_gemeinden/gemeinde_gwr_geb_agg.sql',
        'process_gemeinden/gemeinde_gwr_wohn_agg.sql',
        'process_gemeinden/gemeinde_statpop_array.sql',
        'process_gemeinden/gemeinde_statent_agg.sql',
        'process_gemeinden/strukturdaten_gemeinde.sql'
    ]
}

// Ergebnis als XTF-Datei exportieren
task exportXtf(type: Ili2pgExport, dependsOn: [processZonenschilde, processGemeinden]){
    database = [dbUriProcessing, dbUserProcessing, dbPwdProcessing]
    dbschema = "export"
    disableValidation = false
    dataFile = xtfPath
    models = "SO_ARP_SEin_Strukturdaten_Publikation_20250407"
}

// XTF-Datei auf den SFTP-Server hochladen
tasks.register('upload') {
    dependsOn 'exportXtf'
    doLast {
        ssh.run {
            session(remotes.sftpServer) {
                put from: xtfPath, into: ftpPath
            }
        }
        println "File uploaded to FTP server"
    }
}
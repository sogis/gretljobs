import ch.so.agi.gretl.tasks.*
import ch.so.agi.gretl.api.TransferSet
import java.nio.file.Paths

apply plugin: 'ch.so.agi.gretl'
apply plugin: 'org.hidetake.ssh'

defaultTasks 'updateDispnames', 'uploadZip'

// Definition von Variablen
String tmpDir = buildDir.toString()

String sftpEnvironment = 'prod'

String zipFileName = 'holznutzungsbewilligungen_so_latest.zip'
String zipFilePath = Paths.get(tmpDir, zipFileName).toString()
String xtfFileName = 'SO_holznutzungsbewilligungen_prod.xtf'
String xtfFilePath = Paths.get(tmpDir, xtfFileName).toString()

String dbSchema = 'awjf_holznutzungsbewilligung_v1'
String iliModel = 'Holznutzungsbewilligung_V1_0'
String aiTopic = iliModel.toLowerCase()

// Definition der Zugangsdaten für den Waldportal-SFTP-Server
remotes {
    sftpServer {
        host = sftpServerWaldportal
        user = sftpUserWaldportal
        password = sftpPwdWaldportal
        // Skip host key checking outside the following environments:
        if (!(gretlEnvironment in ['test', 'integration', 'production'])) { // uses the Groovy membership operator
            knownHosts = allowAnyHosts
        }
    }
}

tasks.register('downloadZip') {
    group = 'shared'
    description = 'ZIP-Datei vom Waldportal-SFTP-Server herunterladen'

    // build-Ordner (tmpDir) anlegen, falls nicht existierend
    doFirst {
        buildDir.mkdirs()
    }

    doLast {
        ssh.run {
            session(remotes.sftpServer) {
                get from: "${sftpEnvironment}/holznutzungsbewilligungen/${zipFileName}", into: zipFilePath
            }
        }
        println 'ZIP-Datei vom Waldportal-SFTP-Server heruntergeladen.'
    }
}

tasks.register('unzipXtf', Copy) {
    group = 'updateDatabases'
    dependsOn 'downloadZip'
    description = 'XTF-Datei aus dem ZIP-Archiv extrahieren'

    from zipTree(zipFilePath)
    into tmpDir
}

// Der Katalog kann nicht mit dem Schema-Job importiert werden, darum hier.
// Update, um die Daten (aus dem XTF) nicht in einem separaten Task löschen zu müssen.
tasks.register('importCatalog', Ili2pgUpdate) {
    group = 'updateDatabases'
    dependsOn 'unzipXtf'
    description = 'Import des Katalogs Bewilligte_Holzart_Catalogue in die Edit-DB'

    database = [dbUriEdit, dbUserEdit, dbPwdEdit]
    dbschema = dbSchema
    models = iliModel
    dataFile = files('Holznutzungsbewilligung_Codelisten_V1_0.xml')
    dataset = 'Holznutzungsbewilligung_Codelisten_V1_0.xml'
    importTid = true
}

tasks.register('importXtf', Ili2pgReplace) {
    group = 'updateDatabases'
    dependsOn 'importCatalog'
    description = 'Import der Holznutzungsbewilligungen vom Waldportal in die Edit-DB'

    database = [dbUriEdit, dbUserEdit, dbPwdEdit]
    dbschema = dbSchema
    models = iliModel
    dataFile = files(xtfFilePath)
    dataset = xtfFileName
    importTid = true
}

tasks.register('copyToPub', Db2Db) {
    group = 'updateDatabases'
    dependsOn 'importXtf'
    description = 'Daten vom MGDM in das Publikationsschema überführen'

    sourceDb = [dbUriEdit, dbUserEdit, dbPwdEdit]
    targetDb = [dbUriPub, dbUserPub, dbPwdPub]
    transferSets = [
        new TransferSet('select_holznutzungsbewilligungen.sql', 'awjf_holznutzungsbewilligung_pub_v1.holznutzungsbewilligung', true)
    ]
}

tasks.register('updateDispnames', SqlExecutor) {
    group = 'updateDatabases'
    dependsOn 'copyToPub'
    description = 'Für die Darstellung im WGC den <dispname> von Enumerationen nach <attribut>_txt schreiben'

    database = [dbUriPub, dbUserPub, dbPwdPub]
    sqlFiles = files('update_dispnames.sql')
}

tasks.register('uploadZip') {
    group = 'uploadZip'
    dependsOn 'downloadZip'
    description = 'ZIP-Datei vom Waldportal nach geodienste.ch übertragen und publizieren'

    String aiLogin = "${aiUser}:${aiPwd}"
    String aiUrl = "https://${aiServer}/data_agg/interlis/import"

    doLast {
        def response = [
            'curl', 
            '--user', aiLogin, 
            '--form', "topic=${aiTopic}",
            '--form', "lv95_file=@${zipFilePath}", 
            '--form', 'publish=true', 
            '--form', 'replace_all=false', 
            aiUrl
        ].execute().text

        if (response.contains('false')
                || response.contains('DOCTYPE html')
                || response == null
                || response.trim().isEmpty()
            ) {
            throw new GradleException("Upload zu geodienste.ch fehlgeschlagen: $response")
        } else {
            println(response)
        }
    }
}
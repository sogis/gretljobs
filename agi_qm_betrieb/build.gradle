import java.nio.file.Paths
import java.nio.file.Files
import ch.so.agi.gretl.tasks.*
import ch.so.agi.gretl.api.*

apply plugin: 'ch.so.agi.gretl'
apply plugin: 'org.hidetake.ssh'

defaultTasks 'copyXlsx'

/*
SFTP mit ssh-Plugin, siehe:
- https://github.com/int128/groovy-ssh/blob/77ac597/core/src/main/groovy/org/hidetake/groovy/ssh/operation/SftpOperations.groovy
- https://github.com/int128/groovy-ssh/blob/77ac597/core/src/main/groovy/org/hidetake/groovy/ssh/session/transfer/get/Sftp.groovy
*/

/*
Mit den Verzeichnissen ist es so ne Sache. Erschwert durch Docker. Betrifft 
die relativen Verzeichnisangaben. "." ist glaub in build.gradle was anderes als
in DuckDB. Darum wohl eher absolute Pfade verwenden. Ganz robust wäre es,
wenn man DuckDB den absoluten Pfad als SqlParameter übergeben würde.
*/

def outputFolder = "/tmp/qmbetrieb/"
def xlsxOutputFile = Paths.get(outputFolder, "qm-betrieb.xlsx").toFile()
xlsxOutputFile.delete()
def pathToOutputFolder = Files.createDirectories(Paths.get(outputFolder)).toFile().getAbsolutePath()

def dbUriDuckDB = 'jdbc:duckdb:/tmp/mytemp.duckdb'

def dbHostPub = dbUriPub.substring(dbUriPub.indexOf("//") + 2, dbUriPub.lastIndexOf("/"))
def dbDatabasePub = dbUriPub.substring(dbUriPub.lastIndexOf("/") + 1)
def dbConnectionStringPub = "'dbname=$dbDatabasePub user=$dbUserPub password=$dbPwdPub host=$dbHostPub'"

def dbHostEdit = dbUriEdit.substring(dbUriPub.indexOf("//") + 2, dbUriEdit.lastIndexOf("/"))
def dbDatabaseEdit = dbUriEdit.substring(dbUriEdit.lastIndexOf("/") + 1)
def dbConnectionStringEdit = "'dbname=$dbDatabaseEdit user=$dbUserEdit password=$dbPwdEdit host=$dbHostEdit'"

def dbHostSimi = dbUriSimi.substring(dbUriSimi.indexOf("//") + 2, dbUriSimi.lastIndexOf("/"))
def dbDatabaseSimi = dbUriSimi.substring(dbUriSimi.lastIndexOf("/") + 1)
def dbConnectionStringSimi = "'dbname=$dbDatabaseSimi user=$dbUserSimi password=$dbPwdSimi host=$dbHostSimi'"

remotes {
    sftpServer {
        host = sftpUrlSogis
        user = sftpUserSogis
        password = sftpPwdSogis
        // Skip host key checking outside the following environments:
        if ( !(gretlEnvironment in ['test', 'integration', 'production']) ) { // uses the Groovy membership operator
            knownHosts = allowAnyHosts
        }
    }
}

//-----------

tasks.register('geoDoppelteSchemas', SqlExecutor) {
    database = [dbUriDuckDB] 
    sqlFiles = ["geo_doppelte_schemas.sql"]
    sqlParameters = [
        connectionStringPub : dbConnectionStringPub as String,
        connectionStringEdit : dbConnectionStringEdit as String
        ]
}

tasks.register('geoDoppelteSchemas2Excel', Csv2Excel) {
    description 'Wandelt CSV in eine Excel-Datei um resp. fügt CSV einem neuen Sheet hinzu.'
    dependsOn 'geoDoppelteSchemas'
    csvFile = file("/tmp/qmbetrieb/geo_doppelte_schemas.csv")
    firstLineIsHeader = true
    valueDelimiter = null
    valueSeparator = ";"
    outputFile = xlsxOutputFile
}

//-----------

tasks.register('simiSchemaOhneTabelle', SqlExecutor) {
    database = [dbUriDuckDB]
    sqlFiles = ["simi_schema_ohne_tabelle.sql"]
    sqlParameters = [
        connectionStringSimi : dbConnectionStringSimi as String
        ]
}

tasks.register('simiSchemaOhneTabelle2Excel', Csv2Excel) {
    description 'Wandelt CSV in eine Excel-Datei um resp. fügt CSV einem neuen Sheet hinzu.'
    dependsOn 'simiSchemaOhneTabelle'
    csvFile = file("/tmp/qmbetrieb/simi_schema_ohne_tabelle.csv")
    firstLineIsHeader = true
    valueDelimiter = null
    valueSeparator = ";"
    outputFile = xlsxOutputFile
}

//-----------

tasks.register('simiRasterOhneDatesetView', SqlExecutor) {
    database = [dbUriDuckDB]
    sqlFiles = ["simi_raster_ohne_datasetview.sql"]
    sqlParameters = [
        connectionStringSimi : dbConnectionStringSimi as String
        ]
}

tasks.register('simiRasterOhneDatesetView2Excel', Csv2Excel) {
    description 'Wandelt CSV in eine Excel-Datei um resp. fügt CSV einem neuen Sheet hinzu.'
    dependsOn 'simiRasterOhneDatesetView'
    csvFile = file("/tmp/qmbetrieb/simi_raster_ohne_datasetview.csv")
    firstLineIsHeader = true
    valueDelimiter = null
    valueSeparator = ";"
    outputFile = xlsxOutputFile
}


//-----------

tasks.register('simiTableOhneTableView', SqlExecutor) {
    database = [dbUriDuckDB]
    sqlFiles = ["simi_table_ohne_tableview.sql"]
    sqlParameters = [
        connectionStringSimi : dbConnectionStringSimi as String
        ]
}

tasks.register('simiTableOhneTableView2Excel', Csv2Excel) {
    description 'Wandelt CSV in eine Excel-Datei um resp. fügt CSV einem neuen Sheet hinzu.'
    dependsOn 'simiTableOhneTableView'
    csvFile = file("/tmp/qmbetrieb/simi_table_ohne_tableview.csv")
    firstLineIsHeader = true
    valueDelimiter = null
    valueSeparator = ";"
    outputFile = xlsxOutputFile
}

//-----------

tasks.register('listSftpDirectories') {
    doLast {
        ssh.run {
            session(remotes.sftpServer) {
                sftp {
                    def dirs = ls("./gretl")
                        .findAll({ !(it.filename in ['.', '..']) 
                            && !it.filename.startsWith('.') 
                            && !it.filename.startsWith('robots')
                            && !it.filename.startsWith('nutzungsbedingungen')})
                        .collect({ it.filename }).sort()

                    File lstFile = new File('/tmp/sftpDirectoriesList.csv')
                    lstFile.withWriter{ out ->
                        out.println('kennung')
                        dirs.each {out.println it}
                    }
                    println "File listing saved to: ${lstFile.absolutePath}"
                } 
            }
        }
    }
}

tasks.register('diffKennungSimiDatenabgabe', SqlExecutor) {
    dependsOn 'listSftpDirectories'
    database = [dbUriDuckDB]
    sqlFiles = ["diff_kennung_simi_datenabgabe.sql"]
    sqlParameters = [
        connectionStringSimi : dbConnectionStringSimi as String
        ]
}

tasks.register('diffKennungSimiDatenabgabe2Excel', Csv2Excel) {
    description 'Wandelt CSV in eine Excel-Datei um resp. fügt CSV einem neuen Sheet hinzu.'
    dependsOn 'diffKennungSimiDatenabgabe'
    csvFile = file("/tmp/qmbetrieb/diff_kennung_simi_datenabgabe.csv")
    firstLineIsHeader = true
    valueDelimiter = null
    valueSeparator = ";"
    outputFile = xlsxOutputFile
}

//-----------

tasks.register('relationalThemePublicationCsv', SqlExecutor) {
    description 'Schreibt all vorhandenen Edit-Modell-Themenpublikationen (aka relational) in eine CSV-Datei.'
    database = [dbUriDuckDB]
    sqlFiles = ["relational_theme_publication_csv.sql"]
    sqlParameters = [
        connectionStringSimi : dbConnectionStringSimi as String
        ]
}

tasks.register('superflousPublicationFormatsCsv') {
    description 'Durchsucht anhand der CSV-Datei die Ordner nach shp, gpkg und dxf-Dateien und schreibt das Thema in eine CSV-Datei falls gefunden werden.'
    dependsOn 'relationalThemePublicationCsv'
    doLast {
        def themePublications = new File('/tmp/relational_theme_publication_csv.csv').text.readLines()
        //println themePublications

        ssh.run {
            session(remotes.sftpServer) {
                sftp {
                    def themesWithSuperflousFormats = []
                    themePublications.each { themeDir ->
                        def files = ls("./gretl/$themeDir/aktuell")
                            .findAll({ !(it.filename in ['.', '..', 'meta'])
                                && (
                                    it.filename.contains('gpkg') 
                                    || it.filename.contains('shp')
                                    || it.filename.contains('dxf')
                                )
                            })
                            .collect({ it.filename }).sort()

                        if (files.size() > 0) {
                            themesWithSuperflousFormats.add(themeDir)
                        }
                    }
                    File lstFile = new File('/tmp/qmbetrieb/superflous_publication_formats.csv')
                    lstFile.withWriter{ out ->
                        out.println('kennung')
                        themesWithSuperflousFormats.each {out.println it}
                    }
                    println "File listing saved to: ${lstFile.absolutePath}"
                } 
            }
        }
    }
}

tasks.register('superflousPublicationFormatsCsv2Excel', Csv2Excel) {
    description 'Wandelt CSV in eine Excel-Datei um.'
    dependsOn 'superflousPublicationFormatsCsv'
    csvFile = file("/tmp/qmbetrieb/superflous_publication_formats.csv")
    firstLineIsHeader = true
    valueDelimiter = null
    valueSeparator = ";"
    outputFile = xlsxOutputFile
}

//-----------

tasks.register('simpleThemePublicationCsv', SqlExecutor) {
    description 'Schreibt all vorhandenen Pub-Modell-Themenpublikationen in eine CSV-Datei.'
    database = [dbUriDuckDB]
    sqlFiles = ["simple_theme_publication_csv.sql"]
    sqlParameters = [
        connectionStringSimi : dbConnectionStringSimi as String
        ]
}

tasks.register('countSimplePublicationFormatsCsv') {
    description 'Durchsucht anhand der CSV-Datei die Ordner nach xtf, shp, gpkg und dxf-Dateien und schreibt die jeweilige Anzahl und das Thema in eine CSV-Datei. Es kann vorkommen, dass die Anzahl falsch ist, weil falsche Daten im Ordner liegen. Darum ist es mehr als bloss _missing formats_.'
    dependsOn 'simpleThemePublicationCsv'
    doLast {
        def themePublications = new File('/tmp/simple_theme_publication_csv.csv').text.readLines()
        //println themePublications

        ssh.run {
            session(remotes.sftpServer) {
                sftp {
                    File lstFile = new File('/tmp/qmbetrieb/count_simple_publication_formats.csv')
                    lstFile.withWriter{ out ->
                        out.print('kennung;xtf;gpkg;shp;dxf')
                    }

                    themePublications.each { themeDir ->
                        def xtfFiles = ls("./gretl/$themeDir/aktuell/*.xtf.zip")
                        def gpkgFiles = ls("./gretl/$themeDir/aktuell/*.gpkg.zip")
                        def shpFiles = ls("./gretl/$themeDir/aktuell/*.shp.zip")
                        def dxfFiles = ls("./gretl/$themeDir/aktuell/*.dxf.zip")

                        lstFile << "\n" << "$themeDir;$xtfFiles.size;$gpkgFiles.size;$shpFiles.size;$dxfFiles.size"

                    }
                    println "File listing saved to: ${lstFile.absolutePath}"
                } 
            }
        }
    }
}

tasks.register('countSimplePublicationFormatsCsv2Excel', Csv2Excel) {
    description 'Wandelt CSV in eine Excel-Datei um.'
    dependsOn 'countSimplePublicationFormatsCsv'
    csvFile = file("/tmp/qmbetrieb/count_simple_publication_formats.csv")
    firstLineIsHeader = true
    valueDelimiter = null
    valueSeparator = ";"
    outputFile = xlsxOutputFile
}

//-----------

tasks.register('missingEbauLayer', SqlExecutor) {
    database = [dbUriDuckDB]
    sqlFiles = ["missing_ebau_layer.sql"]
    sqlParameters = [
        connectionStringSimi : dbConnectionStringSimi as String
        ]
}

tasks.register('missingEbauLayer2Excel', Csv2Excel) {
    description 'Wandelt CSV in eine Excel-Datei um.'
    dependsOn 'missingEbauLayer'
    csvFile = file("/tmp/qmbetrieb/missing_ebau_layer.csv")
    firstLineIsHeader = true
    valueDelimiter = null
    valueSeparator = ";"
    outputFile = xlsxOutputFile
}


//-----------

tasks.register('validationTasks') {
    description 'Führt sämtliche Validierungstasks aus.'
    dependsOn 'geoDoppelteSchemas2Excel',
        'simiSchemaOhneTabelle2Excel',
        'simiRasterOhneDatesetView2Excel',
        'simiTableOhneTableView2Excel',
        'diffKennungSimiDatenabgabe2Excel',
        'superflousPublicationFormatsCsv2Excel',
        'countSimplePublicationFormatsCsv2Excel',
        'missingEbauLayer2Excel'
}

//-----------

tasks.register('copyXlsx', Copy) {
    dependsOn 'validationTasks'
    from(outputFolder) {
        include '*.xlsx'
    }
    into file('.')
}
